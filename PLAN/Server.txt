Model-View-Controller architecture

Model
-----

Local database:
User table (UserID, UserName, Privileges, Cash)
User inventory table (UserName, TypeName, PixelCount)
World metadata table (WorldID, WorldName, WorldOwnerName, BoardSize, BoardTime, BoardLockExpiryTime, BoardLockCount, BoardLockCreatorName)

S3 bucket (or local filesystem):
type/TypeName  --> Particle
image/ImageName  --> SVG
world/board/WorldID  --> Board (no grammar)
world/game/WorldID  --> Proto (metadata only; no Board or grammar)
world/proto/WorldID/LockID  --> Proto (metadata + Board + grammar + tools)
world/compiled/WorldID/LockID  --> Game (compiled)

Comments:

WorldID, UserID
 These are 48-bit integer primary keys.

BoardName
 This string is never used as a key, and is not required to be unique.

UserName, TypeName, ImageName
 These are strings that must be unique.

Times (StartTime, ExpirationTime, NextAvailableCheckoutTime, MoveTime)
 board-specific, but generally 64-bit integers measuring (approx) nanoseconds of on-time since deployment.

Cash amounts (CashLevel, CashValue) are measured in virtual dollars, at parity with US$.


Grammar extensions to support multiplayer:

user-particle (similar to particle, but no sane-vars; instead, 48-bit var field reserved for UserID)
player-gstate (similar to gstate, but UserID set to player's ID)
owner-gstate (similar to gstate, but UserID set to World owner's ID)



Views
-----

Resource representations (need a DTD for each of these):

Lock: (LockID, WorldID, LockOwnerUserID, ExpirationTime)
World: (WorldID, LockID?, WorldOwnerUserID, NextAvailableCheckoutTime, Game, OwnershipGoal)
Turn: (PlayerUserID, LockID, MoveLog, UpdatedBoard, UpdatedWorldOwnerUserID)
Type: (TypeDependency*, TypeImageName, TypeParticle)
Price: (TypeName, CashPerPixel)
Status: (UserID, UserName, AvatarImageName, AllowedRole+, OwnedWorldID*, CashLevel, (TypeName,PixelsOwned)+)
PixelPurchaseOrder: ((OrderID, BuyerName, TypeName, CashAmount)+)
Image: SVG

Comments:

The appearance of a "lock collection" is maintained as a RESTful illusion; there can only ever be at most one lock per board.
LockID is just the lock count.

Game data is synthesized dynamically from BucketURLPrefix/world/(game|board)/WorldID
If player doesn't have a lock, world/game/ & world/board/ are used, and the view conforms to proto.dtd.
If player has lock, world/game/ & world/compiled/ are used, view conforms to game.dtd.

Cash amounts are measured in virtual dollars, at parity with US$.


Roles/privileges
----------------

Player - POST/DELETE lock, POST turn, POST order
Artist - POST new image
Vandal - PUT replacement image
Coder - POST new type
Hacker - PUT replacement type


Controller
----------

RESTful HTTP operations & responses.
All can return 401 Unauthorized for authentication (incl. challenge URL)

GET lock/WorldID  -->  303 See Other --> GET lock/WorldID/LockID, 404 Not Found
GET lock/WorldID/LockID  -->  200 Success + Lock (HTTP headers: "Expires"=expiration time, "Last-Modified"=creation time), 404 Not Found
POST lock/WorldID (null)  -->  200 Success + Lock (board proto assembled), 404 Not Found (bad WorldID), 408 Request Timeout (failed to assemble), 423 Locked (someone else's lock), 409 Conflict (too soon since last lock)
DELETE lock/WorldID/LockID  -->  204 No Content (success), 404 Not Found (bad WorldID or LockID), 410 Gone (lock expired)

GET world/board/WorldID  -->   200 Success + Board (HTTP headers: "Last-Modified"=last move) (proxies S3 bucket/filesystem), 404 Not Found (bad WorldID)
GET world/game/WorldID  -->   200 Success + Game metadata (HTTP headers: "Last-Modified"=last change of owner) (proxies S3 bucket/filesystem), 404 Not Found (bad WorldID)
GET world/proto/WorldID/LockID  -->   200 Success + Proto (HTTP headers: "Last-Modified"=lock creation time) (proxies S3 bucket/filesystem), 404 Not Found (bad WorldID or LockID)
GET world/compiled/WorldID/LockID  -->   200 Success + Game (HTTP headers: same as proto) (compiles, caches results in S3 bucket/filesystem), 404 Not Found (bad WorldID or LockID), 408 Request Timeout (failed to compile)

POST turn/WorldID (Turn) -->  204 No Content (success), 410 Gone (lock expired), 423 Locked (not your lock), 403 Forbidden (illegal turn), 402 Payment Required, 413 Request Entity Too Large

GET type/TypeName  -->  200 Success + Type (HTTP headers: "Last-Modified") (proxies S3 bucket/filesystem), 404 Not Found (bad TypeName)
PUT type/TypeName (Type)  -->  204 No Content (success), 403 Forbidden (no coder/hacker privileges), 402 Payment Required, 413 Request Entity Too Large
POST type (Type)  -->  403 Forbidden (currently unimplemented; eventually, redirect internally to "PUT type/TypeName" and return a 303 to "GET type/TypeName")

GET image/ImageName  -->  200 Success + Image (HTTP headers: "Last-Modified") (proxies S3 bucket/filesystem), 404 Not Found (bad ImageName)
PUT image/ImageName (Image)  -->  204 No Content (success), 403 Forbidden (no artist/vandal privileges), 402 Payment Required, 413 Request Entity Too Large
POST type (Image)  -->  403 Forbidden (currently unimplemented; eventually, redirect internally to "PUT image/ImageName" and return a 303 to "GET image/ImageName")

GET price/TypeName  -->  200 Success + Type (HTTP headers: "Expires") (for the moment just returns default price), 404 Not Found (bad TypeName)

GET status/UserID  -->  200 Success + Status, 404 Not Found (bad UserID)

GET order/UserID  -->  200 Success + PixelPurchaseOrder (HTTP headers: "Last-Modified"=time of last purchase) (account history)
POST order/UserID  (PixelPurchaseOrder)  -->  201 Success, 402 Payment Required, 404 Not Found
