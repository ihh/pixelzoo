Scheme rules:
Each cell gets its own initially-empty freeform SXML blob (stored as C string; default = empty = NULL)
- SXML blob is loaded & saved with file
- ZooGas modify rule has four modes: (1) do not modify source or destination SXML blob (default when not modifying type bits), (2) erase the destination cell's SXML blob (default when setting type bits), (2) copy source->destination SXML & erase source (default when copying type bits), (4) swap source<->destination SXML
Add DynamicRule, a new type of Rule: executes a Scheme function dynamically to update the cell. Effectively does { sexp_eval_string(protoTable->context,str=asprintf("(%s %d %d)",dynamicRuleParams->updateFunctionName,x,y),-1,NULL); free(str); rule = dynamicRuleParams->next; }
- Use sexp_define_foreign (or chibi-ffi) to wrap various C functions:
 - Board will need Scheme get/set-accessors for cell states (setCellState x y state) and cell SXML blobs (setCellMeta x y sexp)
 - Also global defines for board size (integer), board depth (integer), random number generator (32-bit int), xy-bounding box of current view area, particle names (int->string), particle types (string->int), and particle varSizes (string->(string->int))
  - NB an avatar is simply a Scheme-scripted agent that uses A* pathfinding to attempt to run to center of current view area
  - Need to record the bounding box of the current view area in the move log

Allow Particle rates to be influenced by state of var (e.g. as a generalization of a fixed rate/asyncFiringRate, offer a C array of such rates, indexed by a named var; or use linear scaling (var+1)/(1<<width) .. log scaling is easy to create with a macro)
- Look up rate in writeBoardStateUnguardedFunction when updating bin trees

Tool rationing:
- Tool levels should be stored in database, and recharges applied for period while world offline.
- This, along with incumbent/challenger tool differences, should be sufficient to implement social play.

Scheme function returning "examine" text
Rewrite PZGameView to use 2:1 isometric grid
PZGameSKView using Sprite Kit, with (64x32px for flat tiles e.g. grass, dirt; 64x128px for tall tiles e.g. people, trees)
- Scheme functions for generating sprite & emitter nodes (from vars & SXML blob)
- API so DynamicRule can generate animations when visible cells are updated


Delete AutoHash, Level, Grammar, simplezoo, polyzoo, zoocompiler from project
Delete Zoo/dtd/proto.dtd

Add a Board Scheme function to create text balloons

Add a default handler to <deliver> rules, so particles that don't implement the rule can be given some default behavior
Allow <deliver> to get message from a register

Modify "world/" controller (authenticated) to list created, owned & neighboring worlds, together with expiry times for active locks & deletion times for any of your old locks
Modify Worlds menu to show up to 3 sections (omitting empty sections): 1) worlds that you control, 2) neighbors of worlds you control, 3) worlds you created

Automatically create one new world per player, at registration time
Add an accomplishments table, also player_accomplishments and worldmeta_required_accomplishments (which determines which worlds you can create)
Add Scheme functions for awarding accomplishments, cash, world creation credits (need to figure out generic but simple reward structure here)

Add (x,y) coordinates for each world, and table of inter-world links (or travel radius?)
Add Galaxy Map view to world info screen; can use this to select neighbors of worlds you control, changing world info view to those neighbors (alternative to selecting via Worlds menu)

Replace current 2D (X*Y) board with 3D slab of height 2 (X*Y*2), allowing for "ground".

Change lock text to be consistent with narrative (e.g. "(creating Einstein-Rosen bridge)", "Orbital exit in 1:00"...)

Add an alert with informative error message for failed lock (rather than just popping)
Add graceful failure modes (alert-then-pop-after-appear) for all NSURLConnection's

Implement ultra-basic, unsafe version of "PUT store/type", with clientside specification of particle dependencies, which automatically associates the Particle with a Tool (using particle_tool table) and adds this tool to a hardwired "experimental toolbox"
Add an experimental world + worldmeta hardwired to use the experimental toolbox
Using PegJS, implement an ultra-basic reaction-diffusion grammar editor (no safety checks, just uses "UserID/" as a prefix on particle names to avoid clashes)

Design some new particle content: a voter-process scintillating wall + spraytool, an SIR zombie model
Port cyclobs, cement, wall, plants, guests to Scheme

Optimization: add bit buffer to Mersenne Twister (included when serializing/initializing seed state)

Conceptually the 7 Rules {Lookup,Compare,Modify,Deliver,Random,Goto,Load} with their various addressing modes can be implemented using the following lower-level, ARM-like primitive opcodes & some conventions:
-LoadRegisterLiteral(Rdest,#val)      [LDR immediate]
-LoadCell(Rxyz,Rd)                    [LDR, memory-mapped neighborhood]
-StoreCell(Rn,Rxyz)                   [STR, memory-mapped neighborhood]
-ExtractBitField(Rd,#lsb,#width,Rn)   [UBFX]
-InsertBitField(Rn,#lsb,#width,Rd)    [BFI]
-AddRegisters(Ra,Rb,Rdest)            [ADD]
-SubtractRegisters(Ra,Rb,Rdest)       [SUB]
-ConditionalBranch(LT,LE,EQ,NE,GT,GE) [B]
-LoadRegisterWithRandom(Rdest,#bits)
-Dispatch(Rxyz,Rmessage)
-WipeCellMeta(Rxyz)
-SwapCellMeta(Rxyz1,Rxyz2)
Example Rxyz format (24bits, 3*signed 8-bit bitfields): x in bits 0-7, y in bits 8-15, z in bits 16-24.
This would facilitate direct generation of ARM code. In practise, generating C code directly from the 7 Rules, and then compiling that, is probably just as effective.
However, this is nice for the paper, due to the natural mapping to ARM.
