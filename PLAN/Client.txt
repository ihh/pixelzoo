As well as {Lookup,Modify,Compare} implement lower-level, ARM-like primitive Rules:
-LoadRegisterFromCellVar(Rx,Ry,Roffset,Rwidth,Rload)
-StoreRegisterToCellVar(Rx,Ry,Roffset,Rwidth,Rstore)
-AddRegisters(Ra,Rb,Rdest)
-CompareRegisters(Ri,Rj;LT,LE,EQ,NE,GT,GE)
...or maybe just (load,store,add,subtract,goto,deliver) and conditional flags on everything including GOTO & DELIVER?


Scheme rules:
Each cell gets its own initially-empty freeform SXML blob (stored as C string; default = empty = NULL)
- SXML blob is loaded & saved with file
- ZooGas modify rule has four modes: (1) do not modify source or destination SXML blob (default when not modifying type bits), (2) erase the destination cell's SXML blob (default when setting type bits), (2) copy source->destination SXML & erase source (default when copying type bits), (4) swap source<->destination SXML
Add ReturnRule, which gives a return value for a Rule (change attemptRule return type to State)
Add DynamicRule, a new type of Rule: executes a Scheme function dynamically to update the cell. Effectively does { sexp_eval_string(protoTable->context,str=asprintf("(%s %d %d)",dynamicRuleParams->updateFunctionName,x,y),-1,NULL); free(str); rule = dynamicRuleParams->next; }
- Use chibi-ffi (or just sexp_define_foreign) to wrap various C functions:
 - Board will need Scheme get/set-accessors for registers (setRegister regnum regval), cell type (setCellType x y strval), cell vars (setCellVar x y varname intval), and cell SXML blob (setCellSXML x y sexp)
 - Also make get-accessors for board size (integer), board depth (integer), random number generator (32-bit int), xy-coords of center of current view area, particle names (int->string), particle types (string->int), and particle varSizes (string->(string->int))
  - NB an avatar is simply a Scheme-scripted agent that uses A* pathfinding to attempt to run to center of current view area
  - Need to record the center of the current view area in the move log

Allow Particle rates to be influenced by state of var (e.g. as a generalization of a fixed rate/asyncFiringRate, offer a C array of such rates, indexed by a named var; or use linear scaling (var+1)/(1<<width) .. log scaling is easy to create with a macro)
- Look up rate in writeBoardStateUnguardedFunction when updating bin trees

Tool rationing:
- Tool levels should be stored in database, and recharges applied for period while world offline.
- This, along with incumbent/challenger tool differences, should be sufficient to implement social play.


Delete AutoHash, Level, Grammar, simplezoo, polyzoo, zoocompiler from project
Delete Zoo/dtd/proto.dtd

Add a Board Scheme function to create text balloons

Add a default handler to <deliver> rules, so particles that don't implement the rule can be given some default behavior
Allow <deliver> to get message from a register

Modify "world/" controller (authenticated) to list created, owned & neighboring worlds, together with expiry times for active locks & deletion times for any of your old locks
Modify Worlds menu to show up to 3 sections (omitting empty sections): 1) worlds that you control, 2) neighbors of worlds you control, 3) worlds you created

Automatically create one new world per player, at registration time
Add an accomplishments table, also player_accomplishments and worldmeta_required_accomplishments (which determines which worlds you can create)
Add Scheme functions for awarding accomplishments, cash, world creation credits (need to figure out generic but simple reward structure here)

Add (x,y) coordinates for each world, and table of inter-world links (or travel radius?)
Add Galaxy Map view to world info screen; can use this to select neighbors of worlds you control, changing world info view to those neighbors (alternative to selecting via Worlds menu)

Replace current 2D (X*Y) board with 3D slab of height 2 (X*Y*2), allowing for "ground".

Scheme function returning "examine" text
Rewrite PZGameView-->PZGameSKView using Sprite Kit (keep PZGameView for debugging)
- Scheme functions for generating sprite & emitter nodes (from vars & SXML blob)
- API so DynamicRule can generate animations when visible cells are updated

Change lock text to be consistent with narrative (e.g. "(creating Einstein-Rosen bridge)", "Orbital exit in 1:00"...)

Add an alert with informative error message for failed lock (rather than just popping)
Add graceful failure modes (alert-then-pop-after-appear) for all NSURLConnection's

Implement ultra-basic, unsafe version of "PUT store/type", with clientside specification of particle dependencies, which automatically associates the Particle with a Tool (using particle_tool table) and adds this tool to a hardwired "experimental toolbox"
Add an experimental world + worldmeta hardwired to use the experimental toolbox
Using PegJS, implement an ultra-basic reaction-diffusion grammar editor (no safety checks, just uses "UserID/" as a prefix on particle names to avoid clashes)

Design some new particle content: a voter-process scintillating wall + spraytool, an SIR zombie model
Port cyclobs, cement, wall, plants, guests to Scheme

Optimization:
- Add a RandomNumberGeneratorBitBuffer (returns one random bit at a time; RandomNumberGenerator still just thinks it's giving out rngRandomInt32's; transiently created & destroyed in sampleBinLeaf; also in evolveBoardCell and evolveBoardCellSync, from where they're passed to attemptRule)
 - Bit buffer should not be preserved between atomic update events (i.e. between cell updates)
