package Zoo::Model::DB;

use strict;
use base 'Catalyst::Model::DBIC::Schema';

__PACKAGE__->config(
    schema_class => 'Zoo::Schema',
    
    connect_info => {
        dsn => 'dbi:SQLite:zoo.db',
        user => '',
        password => '',
        on_connect_do => q{PRAGMA foreign_keys = ON},
    }
);

=head1 NAME

Zoo::Model::DB - Catalyst DBIC Schema Model

=head1 SYNOPSIS

See L<Zoo>

=head1 DESCRIPTION

L<Catalyst::Model::DBIC::Schema> Model using schema L<Zoo::Schema>

=head1 METHODS

=cut

=head2 worlds

Get a list of L<Zoo::Schema::Result::World> identifiers.

=cut

sub worlds {
    my ($self) = @_;
    my @world = $self->resultset('World')->all;
    return @world;
}


=head2 world_by_id

Get a L<Zoo::Schema::Result::World> object, given its identifier.

=cut

sub world_by_id {
    my ($self, $worldId) = @_;
#    $self->storage->debug(1);
    my $world = $self->resultset('World')->find($worldId);
    return $world;
}


=head2 world_active_lock

Get a L<Zoo::Schema::Result::Lock> object, for a given L<Zoo::Schema::Result::World> object.

=cut

sub world_active_lock {
    my ($self, $world) = @_;
#    $self->storage->debug(1);
    my $current_time = time();
    my @locks = $self->resultset('Lock')->search({'world_id' => $world->id,
						  'expiry_time' => { '>' => $current_time }});
    return @locks ? $locks[$#locks] : undef;
}


=head2 delete_locks

Delete all locks that can be deleted.

=cut

sub delete_locks {
    my ($self) = @_;
#    $self->storage->debug(1);
    my $current_time = time();
    my $lock_rs = $self->resultset('Lock')->search_rs({'delete_time' => { '<=' => $current_time }});
    $lock_rs->delete();
}


=head2 particles_by_name

Get a list of L<Zoo::Schema::Result::Particle> objects, given a list of their name identifiers.

=cut

sub particles_by_name {
    my ($self, @particle_names) = @_;
    my @particles = $self->resultset('Particle')->search([map ({ 'name' => $_ }, @particle_names)]);
    return @particles;
}

=head2 tools_by_id

Get a list of L<Zoo::Schema::Result::Tool> objects, given a list of their identifiers.

=cut

sub tools_by_id {
    my ($self, @tool_ids) = @_;
    my @tools = @tool_ids ? $self->resultset('Tool')->search([map ({ 'id' => $_ }, @tool_ids)]) : ();
    return @tools;
}

=head2 descendant_particles

Get the list of L<Zoo::Schema::Result::Particle> objects that are named by, or downstream of all the particles named by, a list of L<Twiggy> objects.

The dependency table is used to find downstream particle dependencies.

=cut

sub descendant_particles {
    my ($self, @twig) = @_;
    my $emptyType = Grammar::defaultEmptyType();
    my %particle_name_hash = ($emptyType => 1);
    for my $twig (@twig) {
	my @names = $twig->particle_names;
#	warn "@names";
	%particle_name_hash = (%particle_name_hash, map (($_ => 1), @names));
    }
    my @particle_names = keys %particle_name_hash;
#    warn "looking for particles (@particle_names)";
    my @particles = $self->particles_by_name (@particle_names);
#    warn "particles (@particles)";
    warn "Some named particles not found" if @particles < @particle_names;
    my @descendants = map ($_->descendants, @particles);
#    warn "descendants (@descendants)";
    my %descendant_hash = map (($_->name => $_), @particles, @descendants);
    # the sort ensures that 'empty' is particle #0; alphabetic sort of remaining particles is just for reproducibility
    my @particles = sort
    { $a->name eq $emptyType ? -1 : ($b->name eq $emptyType ? +1 : ($a->name cmp $b->name)) }
    values %descendant_hash;
#    warn "descendant_particles = (", join(", ",map("'".($_->name)."'",@particles)), ")";
    return @particles;
}

=head1 GENERATED BY

Catalyst::Helper::Model::DBIC::Schema - 0.48

=head1 AUTHOR

Ian Holmes

=head1 LICENSE

This library is free software, you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut

1;
